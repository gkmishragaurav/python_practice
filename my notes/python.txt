Note - Python key can not be a dictionary. only a fixed object can be a key for a dictionary
run a cmd on another machine in python - use pexpect. for same machine use subprocess.

------------------------------------------------------------------------------------------------------

Difference between Compiled and Interpreted Language:

Compiled Language:
	Compiled languages are converted directly into machine code that the processor can execute. 
	It is one where the program, once compiled, is expressed in the instructions of the target machine - machine language; 
	this machine code is undecipherable by humans. Types of compiled language – C, C++, C#, CLEO, COBOL, etc.
	In this language, compiled programs run faster than interpreted programs.
	This language delivers better performance.
	It also gives the developer more control over hardware aspects, like memory management and CPU usage.
	Compiled languages need a “build” step – they need to be manually compiled first. You need to “rebuild” the program every time you need to make a change.

Interpreted Language:
	Interpreters run through a program line by line and execute each command.
	It is one where the instructions are not directly executed by the target machine, 
	but instead read and executed by some other program. Interpreted language ranges – JavaScript, Perl, Python, BASIC, etc.
	While in this language, interpreted programs can be modified while the program is running.
	This languages delivers relatively slower performance.

Okay… but what does that actually mean?
	Imagine you have a hummus recipe that you want to make, but it's written in ancient Greek. 
	There are two ways you, a non-ancient-Greek speaker, could follow its directions.

	The first is if someone had already translated it into English for you. 
	You (and anyone else who can speak English) could read the English version of the recipe and make hummus. 
	Think of this translated recipe as the compiled version.

	The second way is if you have a friend who knows ancient Greek. 
	When you're ready to make hummus, your friend sits next to you and translates 
	the recipe into English as you go, line by line. 
	In this case, your friend is the interpreter for the interpreted version of the recipe.

-----------------------------------------------------------------------------

Internal working of Python:

	Python doesn’t convert its code into machine code, something that hardware can understand.
	It actually converts it into something called byte code, which is stored with a .pyc or .pyo format.
	So within python, compilation happens, but it’s just not into a machine language.
	It is into byte code and this byte code can’t be understood by CPU.
	This bytecode is a low-level set of instructions that can be executed by an interpreter. 
	So we need actually an interpreter called the python virtual machine. 
	The python virtual machine executes the byte codes.

The Python interpreter performs following tasks to execute a Python program :

	Step 1: The interpreter reads a python code or instruction. 
			Then it verifies that the instruction is well formatted, i.e. it checks the syntax of each line.
			If it encounters any error, it immediately halts the translation and shows an error message.
	
	Step 2: If there is no error, i.e. if the python instruction or code is well formatted then the interpreter translates it into its equivalent form in intermediate language called “Byte code”.
			Thus, after successful execution of Python script or code, it is completely translated into Byte code.
	
	Step 3: Byte code is sent to the Python Virtual Machine(PVM).
			Here again the byte code is executed on PVM.
			If an error occurs during this execution then the execution is halted with an error message.
			
Why Interpreted?
	One popular advantage of interpreted languages is that they are platform-independent. 
	As long as the Python bytecode and the Virtual Machine have the same version, Python bytecode can be executed on any platform (Windows, MacOS, etc).
			
What is __pycache__ ?
Many times in your personal project or on GitHub, you might have seen a folder named __pycache__ being created automatically.
As you can see, the filename is the same as the one outside __pycache__ folder. 
The .pyc extension tells us that the file contains bytecode for preprocess.py. 
The names cpython denotes the type of interpreter. CPython means that the interpreter was implemented in C language. 
Similarly, JPython is a Python interpreter implemented in Java.

But why is the folder created in the first place? Well, it slightly increases the speed of the Python program. 
Unless you change your Python code, recompilation to bytecode is avoided, thereby saving time.

--------------------------------------------------------------------------------------------------------------

copy in Python (Deep Copy and Shallow Copy)

In Python, Assignment statements do not copy objects, they create bindings between a target and an object. When we use = operator user thinks that this creates a new object; well, it doesn’t. It only creates a new variable that shares the reference of the original object. Sometimes a user wants to work with mutable objects, in order to do that user looks for a way to create “real copies” or “clones” of these objects. Or, sometimes a user wants copies that user can modify without automatically modifying the original at the same time, in order to do that we create copies of objects.

A copy is sometimes needed so one can change one copy without changing the other. In Python, there are two ways to create copies :

    Deep copy
    Shallow copy

# importing copy module 
import copy 
  
# initializing list 1  
li1 = [1, 2, [3,5], 4] 

# using copy for shallow copy   
li2 = copy.copy(li1)  

# using deepcopy for deepcopy   
li3 = copy.deepcopy(li1)  

----------------------------------------------------------------------------------------
GIL:
The Python Global Interpreter Lock or GIL, in simple words, is a mutex (or a lock) that allows only one thread to hold the control of the Python interpreter.

>>> import sys
>>> a = []
>>> b = a
>>> sys.getrefcount(a)
3

In the above example, the reference count for the empty list object [] was 3. The list object was referenced by a, b and the argument passed to sys.getrefcount().

This means that only one thread can be in a state of execution at any point in time. The impact of the GIL isn’t visible to developers who execute single-threaded programs, but it can be a performance bottleneck in CPU-bound and multi-threaded code.

Q. What problem did the GIL solve for Python?

Python uses reference counting for memory management. It means that objects created in Python have a reference count variable that keeps track of the number of references that point to the object. When this count reaches zero, the memory occupied by the object is released.

The problem was that this reference count variable needed protection from race conditions where two threads increase or decrease its value simultaneously. If this happens, it can cause either leaked memory that is never released or, even worse, incorrectly release the memory while a reference to that object still exists. This can can cause crashes or other “weird” bugs in your Python programs.

The GIL is a single lock on the interpreter itself which adds a rule that execution of any Python bytecode requires acquiring the interpreter lock. This prevents deadlocks (as there is only one lock) and doesn’t introduce much performance overhead. But it effectively makes any CPU-bound Python program single-threaded.

Q. How to deal with Python’s GIL

If the GIL is causing you problems, here a few approaches you can try:

Multi-processing vs multi-threading: The most popular way is to use a multi-processing approach where you use multiple processes instead of threads. Each Python process gets its own Python interpreter and memory space so the GIL won’t be a problem. Python has a multiprocessing module which lets us create processes easily like this:

multi threading in python:

1. MT programming is ideal for programming tasks that are asynchronous in nature, require multiple concurrent activities, and where the processing of each activity may be nondeterministic, i.e., random and unpredictable.

----------------------------------------------------------------------------------------------------------

Python and OS:

a. python sys module
os module
os.system(): Allows us to execute a shell command
os.listdir(path): Returns a list with the contents of the directory passed as an argument
os.walk(path): Navigates all the directories in the provided path directory, and returns three values: the path directory, the names for the sub directories, and a list of filenames in the current directory path.

b. The platform.system() method informs us of the running operating system. Depending on the return value, we can see the ping command is different in Windows and Linux. Windows OS uses ping –n 1 to send one packet of the ICMP ECHO request, whereas Linux or another OS uses ping –c 1.
import os
import platform
operating_system = platform.system()
print operating_system
if (operating_system == "Windows"):
    ping_command = "ping -n 1 127.0.0.1"
elif (operating_system == "Linux"):
    ping_command = "ping -c 1 127.0.0.1"
else :
    ping_command = "ping -c 1 127.0.0.1"
print ping_command

c. subprocess module

d. Working with the filesystem in Python:
understand os.walk
os.path.isfile("./main.py")
os.path.exists("./not_exists.py")
os.makedirs('my_dir')
open a file
read a file
write a file

e. Open file with contaxt manager.

https://jeffknupp.com/blog/2016/03/07/python-with-context-managers/

There are multiple ways to create files in Python, but the cleanest way to do this is by using the with keyword, in this case we are using the Context Manager Approach.
Initially, Python provided the open statement to open files. When we are using the open statement, Python delegates into the developer the responsibility to close the file when it's no longer need to use it. This practice lead to errors since developers sometimes forgot to close it. Since Python 2.5, developers can use the with statement to handle this situation safely. The with statement automatically closes the file even if an exception is raised. In this way, we have the advantage: the file is closed automatically and we don’t need to call the close() method.
>>> with open("somefile.txt", "r") as file:
>>> for line in file:
>>> print line
